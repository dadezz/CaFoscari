\hypertarget{Aifunc_8c}{}\doxysection{Riferimenti per il file src/\+Aifunc.c}
\label{Aifunc_8c}\index{src/Aifunc.c@{src/Aifunc.c}}
{\ttfamily \#include $<$stdlib.\+h$>$}\newline
{\ttfamily \#include $<$string.\+h$>$}\newline
{\ttfamily \#include $<$stdbool.\+h$>$}\newline
{\ttfamily \#include $<$stdio.\+h$>$}\newline
{\ttfamily \#include $<$time.\+h$>$}\newline
{\ttfamily \#include \char`\"{}types.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}func.\+h\char`\"{}}\newline
Grafo delle dipendenze di inclusione per Aifunc.\+c\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{Aifunc_8c__incl}
\end{center}
\end{figure}
\doxysubsection*{Funzioni}
\begin{DoxyCompactItemize}
\item 
void \mbox{\hyperlink{Aifunc_8c_ac8bdc66469646e3add577bc235c158d7}{numeretti}} (\mbox{\hyperlink{structboard__t}{board\+\_\+t}} $\ast$map, \mbox{\hyperlink{structvector__t}{vector\+\_\+t}} $\ast$path, \mbox{\hyperlink{structposition__t}{position\+\_\+t}} inizio, \mbox{\hyperlink{structposition__t}{position\+\_\+t}} fine)
\item 
int \mbox{\hyperlink{Aifunc_8c_afa69436fdf8ab0a1f48c8b311860bc17}{max}} (\mbox{\hyperlink{structvector__t}{vector\+\_\+t}} x)
\item 
bool \mbox{\hyperlink{Aifunc_8c_a1b7a873e7e4bf354ad37adc8e8f84a89}{punto\+\_\+valido}} (\mbox{\hyperlink{structboard__t}{board\+\_\+t}} map, \mbox{\hyperlink{structposition__t}{position\+\_\+t}} p, \mbox{\hyperlink{structvector__t}{vector\+\_\+t}} percorso, int T)
\item 
void \mbox{\hyperlink{Aifunc_8c_a106eca2452f080c23b0b774c1f1e97fa}{elimina\+\_\+passi}} (\mbox{\hyperlink{structvector__t}{vector\+\_\+t}} $\ast$percorso, int x)
\item 
void \mbox{\hyperlink{Aifunc_8c_a96ae72d3de67561d96be28f5416a98de}{scambia\+\_\+punteggio\+\_\+max}} (int punteggio, \mbox{\hyperlink{structvector__t}{vector\+\_\+t}} $\ast$path, \mbox{\hyperlink{structvector__t}{vector\+\_\+t}} $\ast$percorso)
\item 
int \mbox{\hyperlink{Aifunc_8c_a1967973ccb868d860db7fff420da55f9}{best\+\_\+percorso}} (\mbox{\hyperlink{structboard__t}{board\+\_\+t}} map, \mbox{\hyperlink{structvector__t}{vector\+\_\+t}} $\ast$percorso, \mbox{\hyperlink{structvector__t}{vector\+\_\+t}} $\ast$path, \mbox{\hyperlink{structposition__t}{position\+\_\+t}} position, \mbox{\hyperlink{structposition__t}{position\+\_\+t}} fine, int contatore, int bonus, int T, \mbox{\hyperlink{structboard__t}{board\+\_\+t}} $\ast$map\+\_\+orig)
\item 
void \mbox{\hyperlink{Aifunc_8c_a0dc5da805a1711319031dabf046b8163}{mod\+\_\+ai}} (\mbox{\hyperlink{structboard__t}{board\+\_\+t}} $\ast$map)
\end{DoxyCompactItemize}
\doxysubsection*{Variabili}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{Aifunc_8c_ada310e7f72b38fadd4b24d80ed3438ee}\label{Aifunc_8c_ada310e7f72b38fadd4b24d80ed3438ee}} 
time\+\_\+t {\bfseries start}
\item 
\mbox{\Hypertarget{Aifunc_8c_a13455ba845bf5d4dba37be491bc6a036}\label{Aifunc_8c_a13455ba845bf5d4dba37be491bc6a036}} 
time\+\_\+t {\bfseries end}
\item 
\mbox{\Hypertarget{Aifunc_8c_ad2c7b892ba2150459ae0772d7b5c85b3}\label{Aifunc_8c_ad2c7b892ba2150459ae0772d7b5c85b3}} 
double {\bfseries cpu\+\_\+time\+\_\+used}
\item 
\mbox{\Hypertarget{Aifunc_8c_ab87587c1680223f3719acd88c65a93b0}\label{Aifunc_8c_ab87587c1680223f3719acd88c65a93b0}} 
int {\bfseries p\+\_\+max}
\end{DoxyCompactItemize}


\doxysubsection{Descrizione dettagliata}
\begin{DoxyAuthor}{Autori}
Gabriele Cusano (897835), Davide Zambon (898103) 
\end{DoxyAuthor}
\begin{DoxyDate}{Data}
02 feb 2023 
\end{DoxyDate}
\hypertarget{Aifunc_8c_IA}{}\doxysubsection{IA}\label{Aifunc_8c_IA}
Il computer, nel limite massimo di un minuto, deve trovare il percorso migliore (o quello che più gli si avvicina). Sono stati implementati 2 algoritmi\+: (1) “numeretti”\+: A partire dalla cella iniziale, a cui si dà valore 1, si assegna valore 2 alle celle vuote adiacenti, e così via, ogni volta si incrementa di uno. Così facendo, si arriva alla fine col numero di passi minore in assoluto, ma non vengono prese in considerazione le celle speciali. (2) funzione ricorsiva\+: ad ogni passo esplora tutti i possibili percorsi nelle quattro direzioni, calcolando per ognuno il punteggio e restituendo il migliore.

Il problema dell\textquotesingle{}efficienza computativa della (2) viene mitigato in 2 modi\+: (1) riduzione\+: La mappa viene modificata tramite euristiche (quali per esempio riempire di muri i vicoli ciechi opassaggi di larghezza maggiore di 1) che intaccano solo il funzionamento del trapano e solo in piccola parte, dando quindi un enorme vantaggio a fronte di una penalizzazione statisticamente bassa sul punteggio finale. (2) Troncamento\+: Al raggiungimento del minuto, viene restituito il percorso migliore finora trovato. 

\doxysubsection{Documentazione delle funzioni}
\mbox{\Hypertarget{Aifunc_8c_a1967973ccb868d860db7fff420da55f9}\label{Aifunc_8c_a1967973ccb868d860db7fff420da55f9}} 
\index{Aifunc.c@{Aifunc.c}!best\_percorso@{best\_percorso}}
\index{best\_percorso@{best\_percorso}!Aifunc.c@{Aifunc.c}}
\doxysubsubsection{\texorpdfstring{best\_percorso()}{best\_percorso()}}
{\footnotesize\ttfamily int best\+\_\+percorso (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structboard__t}{board\+\_\+t}}}]{map,  }\item[{\mbox{\hyperlink{structvector__t}{vector\+\_\+t}} $\ast$}]{percorso,  }\item[{\mbox{\hyperlink{structvector__t}{vector\+\_\+t}} $\ast$}]{path,  }\item[{\mbox{\hyperlink{structposition__t}{position\+\_\+t}}}]{position,  }\item[{\mbox{\hyperlink{structposition__t}{position\+\_\+t}}}]{fine,  }\item[{int}]{contatore,  }\item[{int}]{bonus,  }\item[{int}]{T,  }\item[{\mbox{\hyperlink{structboard__t}{board\+\_\+t}} $\ast$}]{map\+\_\+orig }\end{DoxyParamCaption})}

funzione ricorsiva 
\begin{DoxyParams}{Parametri}
{\em map} & labirinto di gioco ridotto \\
\hline
{\em percorso} & array per memorizzare tutti i percorsi di esplorazione \\
\hline
{\em path} & array per memorizzare il percorso migliore \\
\hline
{\em position} & la posizione da cui faccio partire l\textquotesingle{}esplorazione a ogni chiamata \\
\hline
{\em fine} & posizione di fine ricorsione, caso base \\
\hline
{\em contatore} & conta i passi effettuati \\
\hline
{\em bonus} & contatore \$ \\
\hline
{\em T} & contatore T \\
\hline
{\em map\+\_\+orig} & labirinto di gioco senza riduzione \\
\hline
\end{DoxyParams}
punteggi.\+data\+: indice 0\+: vado a destra (col+1) indice 1\+: vado giu (riga+1) indice 2\+: vado a sinistra(col-\/1) indice 3\+: vado su (riga-\/1)

il metodo è lo stesso, commento uno solo dei 4 indici\mbox{\Hypertarget{Aifunc_8c_a106eca2452f080c23b0b774c1f1e97fa}\label{Aifunc_8c_a106eca2452f080c23b0b774c1f1e97fa}} 
\index{Aifunc.c@{Aifunc.c}!elimina\_passi@{elimina\_passi}}
\index{elimina\_passi@{elimina\_passi}!Aifunc.c@{Aifunc.c}}
\doxysubsubsection{\texorpdfstring{elimina\_passi()}{elimina\_passi()}}
{\footnotesize\ttfamily void elimina\+\_\+passi (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structvector__t}{vector\+\_\+t}} $\ast$}]{percorso,  }\item[{int}]{x }\end{DoxyParamCaption})}

quando torno indietro, elimino gli ultimi passi che ho fatto dall\textquotesingle{}array, sovrascrivendoli con zeri 
\begin{DoxyParams}{Parametri}
{\em percorso} & lista delle posizioni \\
\hline
{\em x} & indice da cui iniziare a eliminare i passi \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{Aifunc_8c_afa69436fdf8ab0a1f48c8b311860bc17}\label{Aifunc_8c_afa69436fdf8ab0a1f48c8b311860bc17}} 
\index{Aifunc.c@{Aifunc.c}!max@{max}}
\index{max@{max}!Aifunc.c@{Aifunc.c}}
\doxysubsubsection{\texorpdfstring{max()}{max()}}
{\footnotesize\ttfamily int max (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structvector__t}{vector\+\_\+t}}}]{x }\end{DoxyParamCaption})}

max element in a vector \begin{DoxyReturn}{Restituisce}
il valore più alto contenuto in un vettore (non l\textquotesingle{}indice) 
\end{DoxyReturn}
\mbox{\Hypertarget{Aifunc_8c_a0dc5da805a1711319031dabf046b8163}\label{Aifunc_8c_a0dc5da805a1711319031dabf046b8163}} 
\index{Aifunc.c@{Aifunc.c}!mod\_ai@{mod\_ai}}
\index{mod\_ai@{mod\_ai}!Aifunc.c@{Aifunc.c}}
\doxysubsubsection{\texorpdfstring{mod\_ai()}{mod\_ai()}}
{\footnotesize\ttfamily void mod\+\_\+ai (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structboard__t}{board\+\_\+t}} $\ast$}]{map }\end{DoxyParamCaption})}

funzione che sviluppa il gioco la modalità IA 
\begin{DoxyParams}{Parametri}
{\em grid} & mappa su cui si vuol giocare \\
\hline
\end{DoxyParams}
MODALITÀ AI \+: faccio partire un cronometro. per prima cosa faccio partire un cronometro. Trovo in modo sufficientemente veloce un percorso buono, non per forza il migliore, ma comunque una valida alternativa. Lo faccio col metodo dei numeretti, la cui logica è questa\+:

faccio copia del labirinto, come int$\ast$, a tutti i muri e i ! dò valore -\/1 e dò -\/2 ai \$ (-\/1 e -\/2) solo per comodità, va bene qualsiasi numero segnaposto (negativo). dò valore 0 a tutte le celle vuote, e valore 1 alla cella di partenza e mi salvo su variabile esterna al ciclo il valore 1, chiamiamola ZYZZ. Ora faccio un mega ciclo che controlla tutte le celle del labirinto. Ogni volta che trova una cella con valore corrispondente a ZYZZ, guarda se nelle sue vicinanze (NORD; SUD; EST; OVEST) c\textquotesingle{}è una cella con valore == 0 o con valore $>$ ZYZZ. in questa cella viene messo il valore zyzz+1 e, alla fine del ciclo, zyzz viene +=1. il controllo finisce quando si arriva alla fine del ciclo che non ci sono più posti disponibili per mettere ulteriori zyzz. Così facendo, quello che avviene è letteralmente un conteggio dei passi\+: utilizzando tutto il labirinto, quanti passi servono per arrivare al posto finale. Il percorso più breve lo si trova facilmente, guardando, a partire dalla cella finale, le celle adiacenti che hanno il minor valore possibile. Per esempio, se la cella finale ha ZYZZ=100, guardo in direzione E, O, S, N il più basso zyzz che trovo, e mi sposto in quella cella lì. Ovviamente, si arriverà a ZYZZ=1 nella cella iniziale.

poi, per tre minuti al massimo (motivo del cronometro), faccio partire la ricorsione, che usa una mappa ridotta con euristiche (quali caselle ha poco senso includere nei possibili percorsi), per vedere se in quel lasso di tempo trova un candidato migliore come percorso col miglior punteggio. Alla fine il path prescelto è quello col punteggio minore.

CHIAMATA FUNZIONE \char`\"{}\+NUMERETTI\char`\"{}

DA QUI IN POI LA PARTE DI RICORSIONE\mbox{\Hypertarget{Aifunc_8c_ac8bdc66469646e3add577bc235c158d7}\label{Aifunc_8c_ac8bdc66469646e3add577bc235c158d7}} 
\index{Aifunc.c@{Aifunc.c}!numeretti@{numeretti}}
\index{numeretti@{numeretti}!Aifunc.c@{Aifunc.c}}
\doxysubsubsection{\texorpdfstring{numeretti()}{numeretti()}}
{\footnotesize\ttfamily void numeretti (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structboard__t}{board\+\_\+t}} $\ast$}]{map,  }\item[{\mbox{\hyperlink{structvector__t}{vector\+\_\+t}} $\ast$}]{path,  }\item[{\mbox{\hyperlink{structposition__t}{position\+\_\+t}}}]{inizio,  }\item[{\mbox{\hyperlink{structposition__t}{position\+\_\+t}}}]{fine }\end{DoxyParamCaption})}

primo dei due metodi per la risoluzione IA 
\begin{DoxyParams}{Parametri}
{\em map} & labirinto \\
\hline
{\em path} & puntatore al path su cui salvare il percors trovato \\
\hline
{\em inizio} & posizione di inizio \\
\hline
{\em fine} & posizione di fine \\
\hline
\end{DoxyParams}
la prima parte dell\textquotesingle{}and controlla che si stia all\textquotesingle{}interno del campo, la seconda controlla se ho uno spazio vuoto o un nodo che ho raggiunto con un\textquotesingle{}altra via più lunga. (si noti che questo caso ha senso controllarlo solo se ci sono modificatori di zyzz, tipo dollari) se le due condizioni soddisfatte, ci metto il zyzz successivo.

chiarisco\+: i è l\textquotesingle{}indice attuale in path, che contiene la coordinata della cella dove devo andare. di conseguenza, path\mbox{[}i+1\mbox{]} è la coordinata della cella dove mi trovo ora. m\mbox{[}path\mbox{[}i+1\mbox{]}\mbox{]} è lo zyzz della cella dove sto ora. conseguentemente, m\mbox{[}path\mbox{[}i+1\mbox{]}+1\mbox{]} è lo zyzz della cella \char`\"{}sopra\char`\"{} a quella dove sto. controllo quindi se è uno zyzz minore di quello dove sono (e in realtà degli altri disponibili, sto cercando il minimo).\mbox{\Hypertarget{Aifunc_8c_a1b7a873e7e4bf354ad37adc8e8f84a89}\label{Aifunc_8c_a1b7a873e7e4bf354ad37adc8e8f84a89}} 
\index{Aifunc.c@{Aifunc.c}!punto\_valido@{punto\_valido}}
\index{punto\_valido@{punto\_valido}!Aifunc.c@{Aifunc.c}}
\doxysubsubsection{\texorpdfstring{punto\_valido()}{punto\_valido()}}
{\footnotesize\ttfamily bool punto\+\_\+valido (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structboard__t}{board\+\_\+t}}}]{map,  }\item[{\mbox{\hyperlink{structposition__t}{position\+\_\+t}}}]{p,  }\item[{\mbox{\hyperlink{structvector__t}{vector\+\_\+t}}}]{percorso,  }\item[{int}]{T }\end{DoxyParamCaption})}

un punto è valido se non ci sono passato sopra prima e se non è un muro \begin{DoxyReturn}{Restituisce}
true se il punto è valido 
\end{DoxyReturn}

\begin{DoxyParams}{Parametri}
{\em map} & labirinto \\
\hline
{\em p} & posizione che voglio controllare \\
\hline
{\em percorso} & lista delle posizioni già controllate \\
\hline
{\em T} & numero di trapani disponibili (se $>$ 0, un muro è punto valido) \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{Aifunc_8c_a96ae72d3de67561d96be28f5416a98de}\label{Aifunc_8c_a96ae72d3de67561d96be28f5416a98de}} 
\index{Aifunc.c@{Aifunc.c}!scambia\_punteggio\_max@{scambia\_punteggio\_max}}
\index{scambia\_punteggio\_max@{scambia\_punteggio\_max}!Aifunc.c@{Aifunc.c}}
\doxysubsubsection{\texorpdfstring{scambia\_punteggio\_max()}{scambia\_punteggio\_max()}}
{\footnotesize\ttfamily void scambia\+\_\+punteggio\+\_\+max (\begin{DoxyParamCaption}\item[{int}]{punteggio,  }\item[{\mbox{\hyperlink{structvector__t}{vector\+\_\+t}} $\ast$}]{path,  }\item[{\mbox{\hyperlink{structvector__t}{vector\+\_\+t}} $\ast$}]{percorso }\end{DoxyParamCaption})}

cambio il punteggio\+\_\+max ogni e aggiorno path ogni volta che trovo un percorso migliore del migliore precedentemente trovato 
\begin{DoxyParams}{Parametri}
{\em punteggio} & nuovo punteggio \\
\hline
{\em path} & percorso migliore da aggiornare \\
\hline
{\em percorso} & percorso appena trovato \\
\hline
\end{DoxyParams}
