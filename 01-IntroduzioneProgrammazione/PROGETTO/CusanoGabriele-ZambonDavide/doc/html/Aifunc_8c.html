<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Snake Labyrinth: Riferimenti per il file src/Aifunc.c</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Snake Labyrinth
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generato da Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Cerca','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Cerca');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Definizioni</a> &#124;
<a href="#func-members">Funzioni</a> &#124;
<a href="#var-members">Variabili</a>  </div>
  <div class="headertitle">
<div class="title">Riferimenti per il file Aifunc.c</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &lt;string.h&gt;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;time.h&gt;</code><br />
<code>#include &quot;<a class="el" href="types_8h_source.html">types.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="func_8h_source.html">func.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Grafo delle dipendenze di inclusione per Aifunc.c:</div>
<div class="dyncontent">
<div class="center"><img src="Aifunc_8c__incl.png" border="0" usemap="#asrc_2Aifunc_8c" alt=""/></div>
<map name="asrc_2Aifunc_8c" id="asrc_2Aifunc_8c">
<area shape="rect" title=" " alt="" coords="227,5,324,32"/>
<area shape="rect" title=" " alt="" coords="5,155,76,181"/>
<area shape="rect" title=" " alt="" coords="100,155,171,181"/>
<area shape="rect" title=" " alt="" coords="195,155,278,181"/>
<area shape="rect" title=" " alt="" coords="302,155,369,181"/>
<area shape="rect" title=" " alt="" coords="393,155,457,181"/>
<area shape="rect" href="types_8h.html" title=" " alt="" coords="481,155,552,181"/>
<area shape="rect" href="func_8h.html" title=" " alt="" coords="244,80,307,107"/>
</map>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Funzioni</h2></td></tr>
<tr class="memitem:ac8bdc66469646e3add577bc235c158d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Aifunc_8c.html#ac8bdc66469646e3add577bc235c158d7">numeretti</a> (<a class="el" href="structboard__t.html">board_t</a> *map, <a class="el" href="structvector__t.html">vector_t</a> *path, <a class="el" href="structposition__t.html">position_t</a> inizio, <a class="el" href="structposition__t.html">position_t</a> fine)</td></tr>
<tr class="separator:ac8bdc66469646e3add577bc235c158d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa69436fdf8ab0a1f48c8b311860bc17"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Aifunc_8c.html#afa69436fdf8ab0a1f48c8b311860bc17">max</a> (<a class="el" href="structvector__t.html">vector_t</a> x)</td></tr>
<tr class="separator:afa69436fdf8ab0a1f48c8b311860bc17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b7a873e7e4bf354ad37adc8e8f84a89"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Aifunc_8c.html#a1b7a873e7e4bf354ad37adc8e8f84a89">punto_valido</a> (<a class="el" href="structboard__t.html">board_t</a> map, <a class="el" href="structposition__t.html">position_t</a> p, <a class="el" href="structvector__t.html">vector_t</a> percorso, int T)</td></tr>
<tr class="separator:a1b7a873e7e4bf354ad37adc8e8f84a89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a106eca2452f080c23b0b774c1f1e97fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Aifunc_8c.html#a106eca2452f080c23b0b774c1f1e97fa">elimina_passi</a> (<a class="el" href="structvector__t.html">vector_t</a> *percorso, int x)</td></tr>
<tr class="separator:a106eca2452f080c23b0b774c1f1e97fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96ae72d3de67561d96be28f5416a98de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Aifunc_8c.html#a96ae72d3de67561d96be28f5416a98de">scambia_punteggio_max</a> (int punteggio, <a class="el" href="structvector__t.html">vector_t</a> *path, <a class="el" href="structvector__t.html">vector_t</a> *percorso)</td></tr>
<tr class="separator:a96ae72d3de67561d96be28f5416a98de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1967973ccb868d860db7fff420da55f9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Aifunc_8c.html#a1967973ccb868d860db7fff420da55f9">best_percorso</a> (<a class="el" href="structboard__t.html">board_t</a> map, <a class="el" href="structvector__t.html">vector_t</a> *percorso, <a class="el" href="structvector__t.html">vector_t</a> *path, <a class="el" href="structposition__t.html">position_t</a> position, <a class="el" href="structposition__t.html">position_t</a> fine, int contatore, int bonus, int T, <a class="el" href="structboard__t.html">board_t</a> *map_orig)</td></tr>
<tr class="separator:a1967973ccb868d860db7fff420da55f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dc5da805a1711319031dabf046b8163"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Aifunc_8c.html#a0dc5da805a1711319031dabf046b8163">mod_ai</a> (<a class="el" href="structboard__t.html">board_t</a> *map)</td></tr>
<tr class="separator:a0dc5da805a1711319031dabf046b8163"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variabili</h2></td></tr>
<tr class="memitem:ada310e7f72b38fadd4b24d80ed3438ee"><td class="memItemLeft" align="right" valign="top"><a id="ada310e7f72b38fadd4b24d80ed3438ee"></a>
time_t&#160;</td><td class="memItemRight" valign="bottom"><b>start</b></td></tr>
<tr class="separator:ada310e7f72b38fadd4b24d80ed3438ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13455ba845bf5d4dba37be491bc6a036"><td class="memItemLeft" align="right" valign="top"><a id="a13455ba845bf5d4dba37be491bc6a036"></a>
time_t&#160;</td><td class="memItemRight" valign="bottom"><b>end</b></td></tr>
<tr class="separator:a13455ba845bf5d4dba37be491bc6a036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2c7b892ba2150459ae0772d7b5c85b3"><td class="memItemLeft" align="right" valign="top"><a id="ad2c7b892ba2150459ae0772d7b5c85b3"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>cpu_time_used</b></td></tr>
<tr class="separator:ad2c7b892ba2150459ae0772d7b5c85b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab87587c1680223f3719acd88c65a93b0"><td class="memItemLeft" align="right" valign="top"><a id="ab87587c1680223f3719acd88c65a93b0"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>p_max</b></td></tr>
<tr class="separator:ab87587c1680223f3719acd88c65a93b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Descrizione dettagliata</h2>
<div class="textblock"><dl class="section author"><dt>Autori</dt><dd>Gabriele Cusano (897835), Davide Zambon (898103) </dd></dl>
<dl class="section date"><dt>Data</dt><dd>02 feb 2023 </dd></dl>
<h1><a class="anchor" id="IA"></a>
IA</h1>
<p>Il computer, nel limite massimo di un minuto, deve trovare il percorso migliore (o quello che più gli si avvicina). Sono stati implementati 2 algoritmi: (1) “numeretti”: A partire dalla cella iniziale, a cui si dà valore 1, si assegna valore 2 alle celle vuote adiacenti, e così via, ogni volta si incrementa di uno. Così facendo, si arriva alla fine col numero di passi minore in assoluto, ma non vengono prese in considerazione le celle speciali. (2) funzione ricorsiva: ad ogni passo esplora tutti i possibili percorsi nelle quattro direzioni, calcolando per ognuno il punteggio e restituendo il migliore.</p>
<p>Il problema dell'efficienza computativa della (2) viene mitigato in 2 modi: (1) riduzione: La mappa viene modificata tramite euristiche (quali per esempio riempire di muri i vicoli ciechi opassaggi di larghezza maggiore di 1) che intaccano solo il funzionamento del trapano e solo in piccola parte, dando quindi un enorme vantaggio a fronte di una penalizzazione statisticamente bassa sul punteggio finale. (2) Troncamento: Al raggiungimento del minuto, viene restituito il percorso migliore finora trovato. </p>
</div><h2 class="groupheader">Documentazione delle funzioni</h2>
<a id="a1967973ccb868d860db7fff420da55f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1967973ccb868d860db7fff420da55f9">&#9670;&nbsp;</a></span>best_percorso()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int best_percorso </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structboard__t.html">board_t</a>&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvector__t.html">vector_t</a> *&#160;</td>
          <td class="paramname"><em>percorso</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvector__t.html">vector_t</a> *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structposition__t.html">position_t</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structposition__t.html">position_t</a>&#160;</td>
          <td class="paramname"><em>fine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>contatore</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bonus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structboard__t.html">board_t</a> *&#160;</td>
          <td class="paramname"><em>map_orig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>funzione ricorsiva </p><dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>labirinto di gioco ridotto </td></tr>
    <tr><td class="paramname">percorso</td><td>array per memorizzare tutti i percorsi di esplorazione </td></tr>
    <tr><td class="paramname">path</td><td>array per memorizzare il percorso migliore </td></tr>
    <tr><td class="paramname">position</td><td>la posizione da cui faccio partire l'esplorazione a ogni chiamata </td></tr>
    <tr><td class="paramname">fine</td><td>posizione di fine ricorsione, caso base </td></tr>
    <tr><td class="paramname">contatore</td><td>conta i passi effettuati </td></tr>
    <tr><td class="paramname">bonus</td><td>contatore $ </td></tr>
    <tr><td class="paramname">T</td><td>contatore T </td></tr>
    <tr><td class="paramname">map_orig</td><td>labirinto di gioco senza riduzione </td></tr>
  </table>
  </dd>
</dl>
<p>punteggi.data: indice 0: vado a destra (col+1) indice 1: vado giu (riga+1) indice 2: vado a sinistra(col-1) indice 3: vado su (riga-1)</p>
<p>il metodo è lo stesso, commento uno solo dei 4 indici</p>

</div>
</div>
<a id="a106eca2452f080c23b0b774c1f1e97fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a106eca2452f080c23b0b774c1f1e97fa">&#9670;&nbsp;</a></span>elimina_passi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void elimina_passi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvector__t.html">vector_t</a> *&#160;</td>
          <td class="paramname"><em>percorso</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>quando torno indietro, elimino gli ultimi passi che ho fatto dall'array, sovrascrivendoli con zeri </p><dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramname">percorso</td><td>lista delle posizioni </td></tr>
    <tr><td class="paramname">x</td><td>indice da cui iniziare a eliminare i passi </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afa69436fdf8ab0a1f48c8b311860bc17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa69436fdf8ab0a1f48c8b311860bc17">&#9670;&nbsp;</a></span>max()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvector__t.html">vector_t</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>max element in a vector </p><dl class="section return"><dt>Restituisce</dt><dd>il valore più alto contenuto in un vettore (non l'indice) </dd></dl>

</div>
</div>
<a id="a0dc5da805a1711319031dabf046b8163"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dc5da805a1711319031dabf046b8163">&#9670;&nbsp;</a></span>mod_ai()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mod_ai </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structboard__t.html">board_t</a> *&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>funzione che sviluppa il gioco la modalità IA </p><dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>mappa su cui si vuol giocare </td></tr>
  </table>
  </dd>
</dl>
<p>MODALITÀ AI : faccio partire un cronometro. per prima cosa faccio partire un cronometro. Trovo in modo sufficientemente veloce un percorso buono, non per forza il migliore, ma comunque una valida alternativa. Lo faccio col metodo dei numeretti, la cui logica è questa:</p>
<p>faccio copia del labirinto, come int*, a tutti i muri e i ! dò valore -1 e dò -2 ai $ (-1 e -2) solo per comodità, va bene qualsiasi numero segnaposto (negativo). dò valore 0 a tutte le celle vuote, e valore 1 alla cella di partenza e mi salvo su variabile esterna al ciclo il valore 1, chiamiamola ZYZZ. Ora faccio un mega ciclo che controlla tutte le celle del labirinto. Ogni volta che trova una cella con valore corrispondente a ZYZZ, guarda se nelle sue vicinanze (NORD; SUD; EST; OVEST) c'è una cella con valore == 0 o con valore &gt; ZYZZ. in questa cella viene messo il valore zyzz+1 e, alla fine del ciclo, zyzz viene +=1. il controllo finisce quando si arriva alla fine del ciclo che non ci sono più posti disponibili per mettere ulteriori zyzz. Così facendo, quello che avviene è letteralmente un conteggio dei passi: utilizzando tutto il labirinto, quanti passi servono per arrivare al posto finale. Il percorso più breve lo si trova facilmente, guardando, a partire dalla cella finale, le celle adiacenti che hanno il minor valore possibile. Per esempio, se la cella finale ha ZYZZ=100, guardo in direzione E, O, S, N il più basso zyzz che trovo, e mi sposto in quella cella lì. Ovviamente, si arriverà a ZYZZ=1 nella cella iniziale.</p>
<p>poi, per tre minuti al massimo (motivo del cronometro), faccio partire la ricorsione, che usa una mappa ridotta con euristiche (quali caselle ha poco senso includere nei possibili percorsi), per vedere se in quel lasso di tempo trova un candidato migliore come percorso col miglior punteggio. Alla fine il path prescelto è quello col punteggio minore.</p>
<p>CHIAMATA FUNZIONE "NUMERETTI"</p>
<p>DA QUI IN POI LA PARTE DI RICORSIONE</p>

</div>
</div>
<a id="ac8bdc66469646e3add577bc235c158d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8bdc66469646e3add577bc235c158d7">&#9670;&nbsp;</a></span>numeretti()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void numeretti </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structboard__t.html">board_t</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvector__t.html">vector_t</a> *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structposition__t.html">position_t</a>&#160;</td>
          <td class="paramname"><em>inizio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structposition__t.html">position_t</a>&#160;</td>
          <td class="paramname"><em>fine</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>primo dei due metodi per la risoluzione IA </p><dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>labirinto </td></tr>
    <tr><td class="paramname">path</td><td>puntatore al path su cui salvare il percors trovato </td></tr>
    <tr><td class="paramname">inizio</td><td>posizione di inizio </td></tr>
    <tr><td class="paramname">fine</td><td>posizione di fine </td></tr>
  </table>
  </dd>
</dl>
<p>la prima parte dell'and controlla che si stia all'interno del campo, la seconda controlla se ho uno spazio vuoto o un nodo che ho raggiunto con un'altra via più lunga. (si noti che questo caso ha senso controllarlo solo se ci sono modificatori di zyzz, tipo dollari) se le due condizioni soddisfatte, ci metto il zyzz successivo.</p>
<p>chiarisco: i è l'indice attuale in path, che contiene la coordinata della cella dove devo andare. di conseguenza, path[i+1] è la coordinata della cella dove mi trovo ora. m[path[i+1]] è lo zyzz della cella dove sto ora. conseguentemente, m[path[i+1]+1] è lo zyzz della cella "sopra" a quella dove sto. controllo quindi se è uno zyzz minore di quello dove sono (e in realtà degli altri disponibili, sto cercando il minimo).</p>

</div>
</div>
<a id="a1b7a873e7e4bf354ad37adc8e8f84a89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b7a873e7e4bf354ad37adc8e8f84a89">&#9670;&nbsp;</a></span>punto_valido()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool punto_valido </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structboard__t.html">board_t</a>&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structposition__t.html">position_t</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvector__t.html">vector_t</a>&#160;</td>
          <td class="paramname"><em>percorso</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>T</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>un punto è valido se non ci sono passato sopra prima e se non è un muro </p><dl class="section return"><dt>Restituisce</dt><dd>true se il punto è valido </dd></dl>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>labirinto </td></tr>
    <tr><td class="paramname">p</td><td>posizione che voglio controllare </td></tr>
    <tr><td class="paramname">percorso</td><td>lista delle posizioni già controllate </td></tr>
    <tr><td class="paramname">T</td><td>numero di trapani disponibili (se &gt; 0, un muro è punto valido) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a96ae72d3de67561d96be28f5416a98de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96ae72d3de67561d96be28f5416a98de">&#9670;&nbsp;</a></span>scambia_punteggio_max()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void scambia_punteggio_max </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>punteggio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvector__t.html">vector_t</a> *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvector__t.html">vector_t</a> *&#160;</td>
          <td class="paramname"><em>percorso</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>cambio il punteggio_max ogni e aggiorno path ogni volta che trovo un percorso migliore del migliore precedentemente trovato </p><dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramname">punteggio</td><td>nuovo punteggio </td></tr>
    <tr><td class="paramname">path</td><td>percorso migliore da aggiornare </td></tr>
    <tr><td class="paramname">percorso</td><td>percorso appena trovato </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generato da&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
